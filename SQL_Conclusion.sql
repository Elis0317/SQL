/******************************
1章
データベースの作成
	CREATE DATABASE <データベース名>;
	
テーブルの作成
CREATE TABLE <テーブル名>
	(<列名1> <データ型> <この列の制約>,
	 <列名2> <データ型> <この列の制約>,
	 ...
	 <このテーブルの制約1>, <このテーブルの制約2>,...... );


データ型

1. INTEGER（数値）型
	整数のみが入る（少数は入れられない）
	
2. CHAR(文字列型)
	CHAR(10)などのように最大文字数を指定して使う。
	CHAR(8)に'ABC'を代入したとき、'ABC     'という（スペース5つが後ろにつく）形で格納される。
	
3. VARCHAR(可変長文字列)型
	CHARと似ているが、VARCHAR(8)に'ABC'を代入したとき結果は'ABC'である（半角スペースで埋めない）。
	
4. DATE（日付型）
	日付を代入する。代入するときは'1998/10/4'のように ['']でくくること。


制約
1. NOT NULL (NOT NULL制約)
	無記入は不可(エラーを起こす)。

2. PRIMARY KEY（主キー制約）
	一つの行を特定できる（値が絶対に重複しない）列に主キーを当てることで、特定の行のデータを呼び出せる。


テーブルの削除と変更

1. テーブルの削除
	DROP TABLE <テーブル名>;
	※ 一度コマンドを打つと二度と戻らないので注意

2. 列の追加
	ALTER TABLE <テーブル名> ADD COLUMN <列の定義>;
	
3. 列の削除
	ALTER TABLE <テーブル名> DROP COLUMN <列名>;

*****************************/

/*****************************
2章

SELECT文
	テーブルからデータを取り出す時に使う
SELECT	<列名>
FROM	<テーブル名>

********************
SELECT * 				<= 全ての列の意味

SELECT <元の列名> AS <新しい列名>	<= 表示される列名が変化(AS の後ろは日本語でもかまわない)

SELECT DISTINCT				<= 重複を省いた結果が出力される(NULLも重複が省かれ、一つにまとまる)
********************
	
WHERE句による行の選択
	SELECT	<列名>
	FROM	<テーブル名>
	WHERE	<条件式>;

算術演算子
	SQL文には、WHERE文に計算式を記入可能。
	ただし、NULLを含んだ計算式は全てNULLになるので注意 
		※NULL / 0 = NULL,エラーにならない

比較演算子
<, >, = を使った比較がWHERE文で可能。
ただし、文字列の数字は注意
	※例(小さい順に'1', '10', '11', '2', '222', '3')
		(1, 1-0, 1-1, 2, 2-2-2, 3と考えると分かりやすい)
		
IS NULL, IS NOT NULL
	NULLかどうかを判断

論理演算子
	NOT演算子 NOT以降に書かれた文章を否定する

AND演算子、OR演算子
	AND: 両方とも成り立つとき, OR: 少なくとも一方が成り立つとき
	ANDとORを両方使った時は、AND優先なので、ORを優先したい場合は()を使うこと

NULLを含む場合の真理値
	SQLではNULLを比較すると、真でも偽でもない、[不明(UNKNOWN)]という真理値を返す。
	なるべく使わないように気をつけること。
*****************************/

/*****************************
3章

集約関数
1. COUNT
	テーブルのレコード数(行数を数える)
	DISTINCTを使うときは COUNT (DINSTINCT...)の並び順
2. SUM
	テーブルの数値列のデータを合計する
3. AVG
	テーブルの数値列のデータを平均する
4. MAX
	テーブルの任意の列のデータの最大値を求める
5. MIN

	テーブルの任意の列のデータの最小値を求める

テーブルからグループへの切り分け
	今までテーブル全体を一つのグループとしてみなしていたが、GROUP BYによって複数のグループに切り分けられる

SELECT	 <列名1>,<列名2>,<列名3>, ......
FROM	 <テーブル名>
GROUP BY <列名1>,<列名2>,<列名3>, ......; <=GROUP BYに指定する列のことは集約キーと呼ばれる
 
 NULLも一つのグループに分類される（NULL同士も集まる)

WHEREとGROUP BYの併用
	並び順: SELECT => FROM => WHERE => GROUP BY
	実行順: FROM => WHERE => GROUP BY => SELECT
		見た目の並び順と実行順が違うので注意

********************
集約関数とGROUP BY句に関する、よくある間違い

1. SELECT句に余計な列を書く
	集約関数を使うとき、SELECT句に書くことができるのは、
		1. 定数 2. 集約関数 3. GROUP BYで指定した列名(集約キー)
		
	集約キーと他のデータは、必ずしも1対1対応になるとは限らないため
	（集約キーに対して複数の値が存在する列をSELECT句に含めるのは論理的に不可能)

2. GROUP BY句に(SELECT...ASを使った)列の別名を書く
	GROUP BY句はSELECTより先に起動するので、GROUP BY句はこの時点でSELECT句でつけた別名を知らない

3. GROUP BY句を使って結果を選択した時、表示される結果は規則がある?
	SELECTによって表示される結果は全くのランダム
		=>並び順をソートする場合、ORDER BY句で指定する必要がある

4. WHERE句に集約関数を書く
	WHERE句には条件を指定できるが、集約関数を書くことはできない
	<= 集約関数を書けるのはSELECT句、HAVING句、ORDER BY句のみ
********************

集約した結果に条件を指定
HAVING句
	GROUP BY句によって分けられた「グループ」に対して、さらに条件を指定する
		WHEREは「レコード(行)」のみにしか条件を指定できない

SELECT	 <列名1>, <列名2>, <列名3>, ......
FROM	 <テーブル名>
GROUP BY <列名1>, <列名2>, <列名3>, ......
HAVING	 <グループの値に対する条件>

HAVING句に書ける要素
	SELECT句と同じ 1. 定数 2. 集約関数 3. GROUP BYで指定した列名(集約キー)

	GROUP BY句に含まれていない列をHAVING句に入れると、エラーが生じる
	※SELECT句でもHAVING句でも、一度集約が終わった後のテーブルを想像して、コードを書くとミスが減る

集約キーは行に関する条件なので、WHERE句に書くほうが混乱は少ない
	WHERE句:	行に対する条件
	HAVING句	グループに対する条件

検索結果の並び替え
ORDER BY句
	表示されたデータベースの並び替えに用いられ、SELECT文の最後に書く
	
SELECT	 <列名1>, <列名2>, <列名3>, ......
FROM	 <テーブル名>
ORDER BY <並べ替えの基準となる列1>, <並べ替えの基準となる列2>, ......(DESC); <= DESCを入れると降順に

	データにNULLがある場合、先頭もしくは末尾に来る(どちらに来るかは特に決まっていない）

	ソートキーに AS を使うのは許可される(GROUP BYでは使えない)
		実行順: FROM => WHERE => GROUP BY => SELECT => ORDER BYのため

	SELECTに含まれていない列、集約関数も使うことができる
*****************************/

/*****************************
4章

データの登録(INSERT文)
	CREATE TABLE文で作成したテーブルの段階では、｢空っぽの箱」
	=>データを詰めることで｢データベース｣に

INSERT文
	INSERT INTO <テーブル名> (列1, 列2, 列3, ......) VALUES(値1, 値2, 値3, ......);
	文字型・日付型の値を挿入するときは、['']で囲むこと
	
	列名, 値をカンマで区切って、外側を()でくくった形式をリストと呼ぶ。
	列リスト、値リストの列数が一致していないと挿入できない(一致していないとエラー)
		デフォルト値を利用する場合は一致していなくてもよい(後述説明)
	
	基本的に、INSERT文1回の実行では1行を挿入
		挿入する行数だけINSERTを呼び出すのが基本

********************
複数行INSERT
	複数のVALUES句のリストをカンマで区切って並列
		直感的に分かりやすく、記述する分量も減り便利
	
	INSERT文の記述に間違いがあると、特定が大変
	全ての環境で使えるわけではないので注意
********************

列リストの省略
	テーブルの全列に対してINSERTする場合、列リストを省略できる
	この時、VALUES値は左から順に、各列に割り当てられる

NULLの挿入
	NULLを割り当てたい場合、値リストにNULLをそのまま記述
	
デフォルト値の設定
	CREATE TABLE文の制約に DAFAULT <デフォルト値>と記入することで、デフォルト値を挿入可能
	デフォルト値が設定されていない場合、NULLが挿入される
		NOT NULLに注意
	
	1) 明示的挿入
	VALUES句にDEFAULTを指定
	
	2)暗黙的挿入
	デフォルト値が設定されている列を、列リスト・VALUES共に省略してしまえばよい

********************
INSERT...SELECT文
	テーブル同士でデータの受け渡しが可能
	SELECT文中には、WHERE, GROUP BYなどどんなSQL構文でも使うことができる
		ただし、ORDER BYは使っても意味がない
	
INSERT INTO <貼り付け側テーブル> <(列1, 列2, 列3, ......)>
SELECT <(列1, 列2, 列3, ......)>
  FROM <コピー側テーブル>
  
********************

データの削除(DROP TABLE文とDELETE文)

データの削除の方法
	1. テーブルそのものを削除する(DROP TABLE文)
	2.  DELETE文によって、テーブルは残したまま、テーブル内のすべての行を削除する(DELETE文)

DELETE文
	全レコード(行）を削除する
	FROM を忘れない
DELETE FROM <テーブル名>

探索的DELETE
	WHERE句条件を使って、一部の行のみを削除するとき使用
	GROUP BYやHAVINGは、元となるテーブルからデータを選択するとき、｢抽出する形を変える｣のが目的、ここでは出番がない
	ORDER BYも、結果の表示順を指定するためのもの、ここでは出番がない

DELETE FROM <テーブル名>
 WHERE <条件式>


データの更新(UPDATE文)
UPDATE文
	登録済みのデータの変更に使用(データを消して再登録する必要はない）
	
UPDATE <テーブル名>
   SET <列名> = <式>

探索型UPDATE
	探索型DELETE同様、WHEREを使って条件を指定する

NULLで更新
	SETの式をNULLにすることで、列をNULLで更新(書き換え)も可能

複数列の更新
	UPDATE文を2つにせずとも、SET文で2つの列を指定しておくことで、文章をまとめる

	
UPDATE	 <テーブル名>
SET	 <列名1> = <式1>
	 <列名2> = <式2>
	 ...
WHERE	 <条件式>...

トランザクション
	データベースに対する1つ以上の更新をまとめて呼ぶ時の名称
	トランザクション開始文とトランザクション終了文によって更新される
	
	COMMIT: 処理の確定(トランザクションに含まれていた処理による変更をすべて反映）
	=> 間違えたトランザクションを確定してしまうと非常に面倒なので注意
	ROLLBACK: 処理による変更をすべて破棄、終了
	
********************
トランザクションが守るべきこと-ACID特性

Atomicity(原子性)
	トランザクションが終わった時、そこに含まれていた更新処理は、
	全て実行(COMMIT)されるか、または全て実行されない(ROLLBACK)状態で終わることを保証する性質。
	=> 2つの処理をトランザクションとして定義したのに、1つしか実行されて泣ければ業務に支障をきたす

Consistency(一貫性)
	トランザクションに含まれる処理は、データベースにあらかじめ設定された制約を満たす、という性質。
	=> 主キーやNOT NULL制約を満たさない文章を書くと、｢ロールバックされる｣。
	=> 一文単位で実行が取り消され、実行されなかったと同じ事になるので注意
		
Isolation(独立性)
	トランザクション同士が互いに干渉を受けない性質
	=> トランザクション同士が入れ子になることはない
	   (あるトランザクションによる変更は、トランザクション終了時までは別のトランザクションから隠ぺい)
		
	=> あるトランザクションがテーブルにレコードを追加している時、
	   他のトランザクションからは、新規に追加されたレコードはコミットされるまで｢見えない｣

Durability(永続性)
	トランザクションが終了したら、コミット・ロールバックかかわらず、
	その時点でのデータの状態が保存されることを保証する性質。
	=> たとえシステム障害が発生してデータが失われても、何らかの手段でこれを復旧させる手段を持たねばならない
		
	=> 永続性がないと、トランザクションをコミットして終了させても、
	   システムに障害が発生してデータが全部消えて最初から、といった状況が起こりうる
		
	※永続性を保証する集団でポピュラーなものとして、
	トランザクションの実行記録をディスクなどに保存しておき(ログ)、障害が起きた場合はこのログを使って復旧する、という方法がある。
*****************************/

/*****************************
5章

/*****************************
ビュー
	テーブルと同じだが、実際のデータは保存していない
	ビューはSELECT文を保存しており、ビューからデータを取り出そうとするときに、
	ビューは内部的にそのSELECT文を実行し、一時的に仮想のテーブルを作る

ビューのメリット
	1. データを保存しないため、記憶装置の容量を節約できる
	2. 頻繁に使うSELECT文をいちいち毎回書かなくても、ビューとして保存することで使い回しが効く
		一度ビューを作っておけば、呼び出すだけで簡単にSELECT文の結果が得られる
		
		ビューが含むデータは、元のデータと連動して自動的に最新の状態に更新される
			｢ビューを参照する」 = 「そのSELECT文を実行する」

CREATE VIEW ビュー名 (<ビューの列名1>, <ビューの列名2>, ......)
AS
<SELECT文>


ビューの制限事項
	1. ビュー定義で ORDER BYは使えない
	   => テーブル同様、ビューについても｢行には順序がない｣ため。
		
	2. ビューに対する更新
	   => ビューに対して、INSERT, DELETE, UPDATEなどは基本的に使用不可
	   	
	エラーの具体例
	INSERT INTO ShohinSum VALUES ('電化製品', 5);
		 
		 この場合、ShohinSumビューでは正常な処理（商品分類が電化製品、商品数が5）が行える。
		 しかし、ShohinSum｢テーブル｣からみるとINSERT文は、
		 	「テーブルのshohin_bunruiに5レコード追加すること」しか分からない。
		 	（つまり、商品IDや販売単価など、商品分類以外は不明の行が、5行できることになる）
		 	

ビューの削除
	DROP VIEW文を使う。
DROP VIEW ビュー名 (<ビューの列名1>, <ビューの列名2>, ......)

サブクエリ
	ビュー: データを取り出すSELECT文だけを保存する方法
	サブクエリ: ビュー定義のSELECT文をそのままFROM句に持ち込んだもの
	
SELECT ...		) 2. 外側のクエリ(SELECT文）が実行
  FROM (
  	SELECT ...	)
  	  FROM ...	) 1. 内側のクエリ(サブクエリ）から実行
  	 GROUP ...	)
) AS [名前｣

	FROM句にさらにサブクエリを使うことで、入れ子を深くすることが可能。
	読みづらくなるのであまり入れすぎないように

	サブクエリには名前を付ける必要があり、処理内容から考えた適切な名前を付ける必要がある。
	名前の前のASは省略可能。


スカラ・サブクエリ
	サブクエリ: 構造的にはテーブルと同じなので、基本的に複数行を結果として返す。
	スカラ・サブクエリ: 「必ず1行1列だけの戻り値を返す」という制限を付けたサブクエリ
	=> 戻り値が単一なので、サブクエリの戻り値を比較演算子(<, >, =, など)の入力として用いることができる。

	定数や列名を書けることのできる場所すべてで書くことができる
	=> SELECT, GROUP BY, HAVING, ORDER BYなど...
	
	複数行を返さないことを確認して使う（複数行の時点でスカラ・サブクエリではない）

相関サブクエリ
	テーブルの一部のレコード集合に限定した比較を行う場合に用いる

例: 「商品分類ごと」に平均販売単価を比較する
SELECT shohin_bunrui, shohin_mei, hanbai_tanka
  FROM Shohin AS S1
 WHERE hanbai_tanka > (SELECT AVG(hanbai_tanka)
                         FROM Shohin AS S2
                        WHERE S1.shohin_bunrui = S2.shohin_bunrui --<=相関サブクエリ
                        GROUP BY shohin_bunrui);
                        
	各商品の販売単価と平均単価の比較を、「同じ商品分類の中で」行う
	相関サブクエリでは、テーブルの別名を列名の前に <テーブル名>.<列名>の形式で記述する必要がある
******************************/

/*****************************
6章

関数の種類
	1. 算術関数: 数値の計算を行う関数
	2. 文字列関数: 文字列を操作するための関数
	3. 日付関数: 日付を操作するための関数
	4. 変換関数: データ型や値を変換するための関数
	5. 集約関数: データの集計を行うための関数 --習得済み


1. 算術関数

ABS(数値)
	絶対値を求める関数

MOD(被序数, 序数)
	剰余を求める関数
	余りという概念上、整数型の列だけになる

ROUND(対象数, 丸めの桁数)
	四捨五入する関数
	丸めの桁数までの数値が表示される: 0 => 整数値, 2 => 小数第2位まで（小数第3位を四捨五入)


2.文字列関数

文字列1 || 文字列2
	連結
	足す文字がNULLの場合、結果はNULL
	3つ以上つなげることも可能

LENGTH（文字列）
	文字列長
	文字が何文字か調べる

LOWER（文字列）
	小文字化
	アルファベットの大文字のみに関係し、全て小文字にする
	小文字から大文字はUPPER

REPLACE(対象文字列, 置換前の文字列, 置換後の文字列)
	置換
	文字列中のある一部分の文字列を別の文字列におきかえる

SUBSTRING(対象文字列 FROM 切り出し開始位置 FOR 切り出す文字数)
	切り出し
	文字列中のある一部分の文字列を切り出す
	FROMとFORの後ろは整数値が入り、「何文字目から」「何文字抜き出す」かを指定する


3.日付関数

CURRENT_DATE
	現在の日付
	この関数が実行された日を戻り値として返す

CURRENT_TIME
	現在の時間
	この関数が実行された時間を戻り値として返す

CURRENT_TIMESTAMP
	現在の日時
	この関数が実行された日時を戻り値として返す

EXTRACT(日付要素 FROM 日付)
	日付要素(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)の切り出し
	日付データから「年」や「月」、「秒」を切り出す場合に使う
	戻り値は数値型


4. 変換関数

CAST(変換前の値 AS 変換するデータ型
	型変換
	型が不一致故のエアーを回避させる

COALESCE（データ1, データ2, データ3, ......)
	NULLを値へ変換
	左の引数から順に見ていき、初めてNULLでなかった時の数値を返す
	例: NULL NULL 3 NULL 5の場合、戻り値は3
	
	NULLが演算・関数に紛れ込むと全てNULLになるため、それを避ける時に重宝


述語	戻り値が真理値になる関数のこと

LIKE述語
	文字列の部分一致検索
	前方一致 例: ddd%	[ddd + （0文字以上の文字列)]							dddabcなど
	中間一致 例: %ddd%	[（0文字以上の文字列) + ddd + （0文字以上の文字列)]		dddabc, adddbc, abcdddなど
	後方一致 例: %ddd	[（0文字以上の文字列) + ddd]							abcdddなど
	
	%の代わりに_を使うと、(任意の1文字)の意味になる

<列データ> BETWEEN <最小値> AND <最大値>
	範囲検索
	両端を含むので、含みたくない場合は BETWEENではなく、 (最小値) < k AND k < (最大値) を使う必要がある

IS NULL, IS NOT NULL
	NULL, 非NULLの判定

IN(値1, 値2, ......)
	ORの便利な省略形		--TRUE: 値1, 値2...
	NORの便利な省略形は NOT IN	--TRUE: 値1, 値2...以外
	
	どちらもNULLは引数に選択できない

	INはテーブル・ビューを引数に指定できる
	=> IN(NOT IN)述語の引数にサブクエリ(SQL内部で精製されたテーブル)を指定

例) 「大阪店に置いてある商品の販売単価」を求める
SELECT	 shohin_mei, hanbai_tanka
FROM	 Shohin
WHERE	 shohin_id IN (SELECT shohin_id		--)
		 FROM TenpoShohin		--) このサブクエリが展開されると、
		 WHERE tenpo_id = '000C');	--) ('0003', '0004', '0006', '0007') という結果が得られる

EXISTS述語
	EXISTSはこれまでに学んだ述語とは使い方が異なり、意味を直感的に理解するのが難しい
	EXISTを使わなくてもIN(NOT IN)によって、「ほぼ」代用できる
	
	ある条件に合致するレコードの存在有無を調べる
		レコードが存在すればTRUE, しないならFALSE
		EXISTSの実行により、FROMテーブル中のTRUEのレコードのみが選択される
		
		EXISTSの主語はレコード

	左側に(列の)引数はなく、右側に相関サブクエリ1つのみを引数として取る
	※ 他の述語(BETWEEN, LIKE...)などは <列> BETWEEN <値1> and <値2> など、2つ以上を引数に取る
	
	EXISTS ( SELECT *
		 FROM	 <テーブル名> AS <テーブル名>
		 WHERE	 <相関サブクエリ>
		);
	
例) 「大阪店に置いてある商品の販売単価」を求める
SELECT	 shohin_mei, hanbai_tanka
FROM	 Shohin AS S
WHERE	 EXISTS (SELECT	 * 				--)
		 FROM	 TenpoShohin AS TS		--) EXISTS述語が展開されると、
		 WHERE	 TS.tenpo_id = '000C'		--) 条件に合ったレコードのみが残る
		 AND	 TS.shohin_id = S.shohin_id);	--)
		 
NOT EXISTS
	サブクエリ内で指定した条件のレコードが存在しない場合にTRUEを返す


CASE式
	条件分岐（場合分け）を記述するときに使う
	CASE式は式が書ける場所ならどこにでも記述可能
	
CASE WHEN <評価式> THEN <式>
     WHEN <評価式> THEN <式>
     WHEN <評価式> THEN <式>
     ...
     ELSE <式>
END

	評価式: 戻り値が真理値になる式(=, !=, LIKE, BETWEENなど)
*****************************/

/*****************************
7章
集合演算
	別のテーブルから列を持ってきて、｢行」を増やす操作
	
テーブルの足し算と引き算
	足し算（和集合)
SELECT	 <列データ1>, <列データ2>, ...
FROM	 <テーブル1>
UNION
SELECT	 <列データ1>, <列データ2>, ...
FROM	 <テーブル2>

重複行を残す集合演算
	UNION の後ろにALL をつける


********************
集合演算の注意事項
	1. 演算対象となるレコードの列数は同じであること
	2. 足し算の対象となるレコードの列のデータ型が一致していること
		どうしても違うデータ型の列を使いたい場合は、型変換関数CASTを用いる
	3. SELECT文はどんなものを指定してもよいが、ORDER BY句は最後に一つだけ
********************

INTERSECT(交差)
	2つのレコードの共通部分を選択

EXCEPT(差)
	テーブル1のレコードからテーブル2のレコードを引いた残りを選択


結合
	別のテーブルから列を持ってきて、「列」を増やす操作
		
	どちらのテーブルにも存在する列(A)を橋渡しにして、
	片方のテーブルにしか存在しない列(B)同士を一緒の結果に含める

内部結合(INNER JOIN)
	1. FROM句に2つのテーブルを書く
		テーブル名が長いと読みづらいので、一般的にはASで別名をつける
	
	2. 結合条件を指定する必要がある
		2つのテーブルを結び付ける列(結合キー)を指定する
		=> 結合条件専用のWHEREのようなもの(基本的に = でキーを結び付ける)
		
		a.ON
		   WHERE句と同じ書式で結合条件を絞り込む。
		   SELECT … FROM table1 JOIN table2 ON table1.id_a = table2.id_b
		
		b.NATURAL
		   両方のテーブルを比較して名前が同じ全てのカラムを結合条件にして絞り込む
		   SELECT … FROM table1 NATURAL JOIN table2
		   
		   table1, 2両方にid, name, ageがあった場合、これらすべてが結合条件となる
		   記述が短いが、カラムがそろっていないと使えない
	
	3. SELECT句の書き方
		<テーブル名の別名>.<列名>という記述によって、どのテーブルのどの列を持ってきているか明示する

内部結合とWHEREの組み合わせ
	結合演算によりテーブルを結合した後は、WHERE, GROUP BY, ORDER BYなどを使うことができる
	SELECT文が実行されている間しか内部結合テーブルは存続しないので、常に残したいならビューを作成する


OUTER JOIN(外部結合)
	どちらか一方のテーブルに存在しているならば、そのテーブルの情報が欠けることなく出力される
	テーブルから分からない情報はNULLとして結果に表れる
	   ※内部結合では、一方のテーブルにしか存在していないテーブルは結果に出ない
	
	   元のテーブルにない（つまりテーブルの外部から）情報を結果に持ってくる
	
マスタテーブルの指定
	FROM句内でLEFT, RIGHTを使うことでマスタテーブルを指定する
	=> 指定されたマスタテーブルの情報が全て表示される
	
	LEFT, RIGHTに機能的な差はない
	
	
3つ以上のテーブルを使った場合
	3つ以上のテーブルを同時に結合することも可能
	FROM句にINNER JOINを重ねていけばいい

	SELECT	 … FROM table1 AS T1 JOIN table2 AS T2 
	ON	 T1.id_a = T2.id_b
	INNER JOIN table3 AS T3
	ON	 T1.id_a = T3.id_c
*****************************/

/*****************************
8章	
	
ウィンドウ関数(OLAP関数)
	OLAP: Online Analytical Processing
	データベースを使ってリアルタイムに(=オンラインで）データ分析を行う処理のこと
		例） 市場分析、財務諸表作成、計画作成...

<ウィンドウ関数> OVER ([PARTITION BY <列リスト>]
		ORDER BY <ソート用列リスト>)
	
	ウィンドウ関数として使える関数
		1. 集約関数(SUM, AVG, COUNT, MAX, MIN)
		2. ウィンドウ専用関数(RANK, DENSE_RANK, ROW_NUMBERなど)
	
	ウィンドウ関数はGROUP BY句のカット機能とORDER BY句の順序づけの両方を持っている
	=> ただし、PARTITION句には、GROUP BY句が持つような集約機能はない
	
	PARTITION BYによって区切られたレコードの集合を｢ウィンドウ」と呼ぶ
	=> ウィンドウは｢範囲｣を示す
		
	PARTITION BYは必須ではない
	=> 指定しない場合、テーブル全体が一つの大きなウィンドウとして扱われる

ウィンドウ専用関数
	ウィンドウ専用関数は引数を取らない => （）内は常に空
	
RANK関数
例) Shohinテーブルに含まれる8つの商品について、商品分類別に販売単価の安い順で並べたランキング表を作る
SELECT	 shohin_mei, shohin_bunrui, hanbai_tanka,
	 RANK () OVER (PARTITION BY shohin_bunrui
			 ORDER BY hanbai_tanka) AS ranking
FROM	 Shohin;


PARTITION BY
	順位を付ける対象の範囲(例では、商品分類が同じものの中でランク付け)
	GROUP BYとイメージが似ている
	PARTITION BYを指定しなくてもよい（例でこれを指定しないと、テーブル全てにおいて販売単価でランク付け）

ORDER BY
	どの列を、どんな順序で順位を付けるか(例では、販売単価の低い順)
	ASC/DESKを使うことで昇順か降順を決められる（ASCは省略可能）
	
RANK, DENSE_RANK, ROW_NUMBERの違い
	同順位が複数出た時の処理が違う
	RANK:		同順位が複数レコード出た場合、後続の順位は飛ぶ。
			=> 1位が3レコード => 1, 1, 1, 4...
	DENSE_RANK:	同順位が複数レコード存在しても、後続の順位は飛ばない。
			=> 1位が3レコード => 1, 1, 1, 2...
	ROW_NUMBER_:	同順位が複数レコード出た場合、DBMSが適当な順序で連番を付与する。
			=> 1位が3レコード => 1, 2, 3, 4...

ウィンドウ関数を用いることができる場所
	基本的にSELECT句のみ
	
	ウィンドウ関数は、WHERE句やGROUP BY句による処理が終わった｢結果｣に対して作用する
	=> ランキングを出した後にWHERE句やGROUP BY句でレコードが減少・集約されたらランキングは意味をなさない


集約関数をウィンドウ関数に
	集計対象は自分よりも上のレコードだけ
	自分のレコード(カレントレコード）を基準に集計対象を判断する
	
SUM関数
	累計を示す
	レコード1: データ1の合計, レコード2: データ1+データ2の合計, レコード3: データ1+データ2+データ3の合計...
	
AVG関数
	自分より上のレコードの平均を示す
	レコード1: (データ1)/1, レコード2: (データ1+データ2)/2, レコード3: (データ1+データ2+データ3)/3...


フレーム
	ウィンドウの中でさらに集計範囲を細かく設定
	ORDER BY句の後ろに範囲指定のキーワードを使用

移動平均の算出
	｢ここ最近のデータ」の平均を出すときに使う (ここ1週間、ここ3カ月、ここ10年...)
	
例) 集計対象のレコードを｢直近の3行」にする
SELECT	 shohin_id, shohin_mei, hanbai_tanka
	 AVG (hanbai_tanka) OVER (ORDER BY shohin_id
	 			ROWS 2 PRECEDING) AS moving_avg
	
	ROWS(行), PRECEDING(前の)
		ROWS 2 PRECEIDING: 2行前まで
		=> 自分(カレントレコード), 自分より1行前のレコード, 自分より2行前のレコード の3行、というフレーム指定
	
		FOLLOWING(後の)を使うと、〜行後までという指定が可能
			PRECEIDINGとFOLLOWの組み合わせも可能
				ROWS BETWEEN 1 PRECEIDING AND 1 FOLLOWING =>1行前から1行後まで

ORDER BYの仕様
	OVER 内のORDER BYにはウィンドウ関数がどういう順序で計算するかを決める役割しかない
	=> OVER 内のORDER BYで指定した順に結果が並ぶとは限らない

	文末にORDER BYを(合計で2回）使わないと、指定した順番に並ばない可能性がある


GROUPING演算子
	小計・合計を一度に求める
	1. ROLLUP, 2. CUBE, 3. GROUPING SETS

1. ROLLUP
	集約キーの組み合わせが異なる結果を一度に計算する
	GROUP BY句の集約キーリストに対して、ROLLUP (<列1>, <列2>, ...)のように使用
	
	例1) ROLLUPで合計行と小計を一度に求める
	SELECT	 shohin_bunrui, SUM(hanbai_tanka) AS sum_tanka
	FROM	 Shohin
	GROUP BY ROLLUP(shohin_bunrui);
	
	上の例では、
	   1. GROUP BY ()
	   	集約キーなし = GROUP BY句がない状態
	   	=> 全体の合計行のレコードを生成
	   		※超集合行と呼ばれる(GROUP BY句で作られない合計の行のこと)
	   	
	   2. GROUP BY (shohin_bunrui)
	   	集約キー = shohin_bunrui
	両方を一緒に求めている。
	
	例2) 集約キーに登録日を追加した場合
	SELECT	 shohin_bunrui, SUM(hanbai_tanka) AS sum_tanka
	FROM	 Shohin
	GROUP BY ROLLUP(shohin_bunrui, torokubi);
	
	上の例では、
	   1. GROUP BY ()	   	
	   2. GROUP BY (shohin_bunrui)
	   3. GROUP BY (shohin_bunrui, torokubi)
	全てを一緒に求めている。
	
	出力されるのは、商品の単価、商品分類ごとの小計(キッチン用品、事務用品、衣服)、合計が全て出力される。
	
	********************
	GROUPING関数
		超集合行のNULLとそれ以外のNULLを見分ける
		=> 超集合行のNULLが見分けられたら、それだけを別の文字列に書き換え可能
			
		引数に取った列の値が超集合行のために発生したNULLなら1, それ以外なら0を返す
		=> 戻り値が1の時は合計・小計といった文字列をCASE-WHENなどで指定するとより出力結果が分かりやすい
		
	GROUPING(<列データ>) AS <列データ>
	********************
	
	例)超集合行のキー値に適当な文字列を埋め込む
	SELECT	 CASE	WHEN GROUPING(shohin_bunrui) = 1
			THEN '商品分類 合計'
		 	ELSE shohin_bunrui END AS shohin_bunrui			--<=CASE-WHENの終わりはENDをつけること
		 
		 CASE	WHEN GROPING(torokubi) = 1
		 	THEN '登録日 合計
		 	ELSE CAST(torokubi AS VARCHER(16)) END AS torokubi	--<=CASEでの戻り値の型は統一すること
		 								--<=今回は文字列型と日付型だったので、日付型を文字列型に変換
		 SUM(hanbai_tanka) AS sum_tanka
	FROM	 Shohin
	GROUP BY ROLLUP(shohin_bunrui, torokubi);
	
2. CUBE
	GROUP BY句に与えられた集約キーの｢すべての可能な組み合わせ」を一つの結果にまとめる
	キーが2つなら2^2 = 4, 3つなら2^3 = 8
	
	一つの集約キーを座標軸に見立て、データを積み上げるイメージ

3. GROUPING SETS
	欲しい積み木だけ取得
	ROLLUP, CUBEで求めた結果の、一部のレコードだけ求めればいい場合に用いる
	非定形故に、使う機会はそう多くない
*****************************/